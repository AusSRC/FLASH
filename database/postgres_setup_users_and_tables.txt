# flashdb is hosted on 146.118.64.208
ssh -i ~/src/aussrc.pem ubuntu@146.118.64.208

sudo -u postgres psql
create user flash with password 'aussrc';
drop database flashdb with (FORCE);
create database flashdb;
grant all privileges on database flashdb to flash;

# Removing orphaned large objects:
# You can use the utility 'vacuumlo' outside of postgres, ie on the linux command line:
vacuumlo -U flash flashdb

# Re-login as flash user:
psql -U flash -d flashdb

# Create the tables:

create table spect_run (
    id int generated always as identity PRIMARY KEY,
    SBIDs int[],
    config_tar bytea,
    errlog text,
    stdlog text,
    platform varchar(50),
    run_tag varchar(100),
    date TIMESTAMP
);

create table detect_run (
    id int generated always as identity PRIMARY KEY,
    SBIDs int[],
    config_tar bytea,
    errlog text,
    stdlog text,
    result_filepath varchar(100),
    results text,
    platform varchar(50),
    run_tag varchar(100), 
    date TIMESTAMP
);

create table SBID (
    id int generated always as identity PRIMARY KEY,
    sbid_num int NOT NULL,
    spect_runid int,
    detect_runid int,
    spectralF boolean,
    detectionF boolean,
    ascii_tar oid,
    detect_tar oid,
    quality varchar(50),
    version int NOT NULL
);

alter table SBID drop constraint check_types;
alter table SBID add constraint check_types check (quality in ('GOOD','BAD','UNCERTAIN','REJECTED','NOT_VALIDATED') );

alter table sbid add column comment text;
alter table sbid add column results text;
alter table SBID add column spectral_config_tar bytea;
alter table SBID add column detect_config_tar bytea;
alter table SBID add column pointing text;

create table component (
    comp_id varchar(100) NOT NULL,
    component_name varchar(100),
    ra_hms_cont varchar(50,
    dec_dms_cont varchar(50,
    ra_deg_cont varchar(50,
    dec_deg_cont varchar(50,
    processState varchar(50) NOT NULL,
    opd_plotname varchar(100),
    flux_plotname varchar(100),
    fluxfilter real,
    flux_cutoff varchar(50),
    flux_peak real,
    flux_int real,
    has_siblings int,
    opd_image bytea,
    flux_image bytea,
    mode_num int,
    ln_mean real,
    spectral_date TIMESTAMP,
    detection_date TIMESTAMP,
    sbid_id int NOT NULL,
    id int generated always as identity PRIMARY KEY,
    constraint fk_sbid_id
        foreign key(sbid_id) references SBID(id) on delete cascade
);

alter table component add constraint check_flux check (flux_cutoff in ('ABOVE','BELOW') );
alter table component add column comment text;

create table reports (
    id int generated always as identity PRIMARY KEY,
    name varchar(100) NOT NULL,
    author varchar(100) NOT NULL,
    sbid_id int,
    spect_runid int,
    detect_runid int,
    report oid,
    date TIMESTAMP

#########################################################################################
######### NOT USED ######################################################################

alter TABLE spect_run ADD COLUMN run_tag varchar(100);
update spect_run set run_tag = 'flash survey 1';
alter TABLE detect_run ADD COLUMN run_tag varchar(100);
update detect_run set run_tag = 'flash survey 1';
# Search in ARRAY
update spect_run set run_tag = 'ASKAP pilot' where 15211 = any(sbids);

# Join table:
select sbid.id,sbid.spect_runid,spect_run.run_tag from sbid inner join spect_run on sbid.spect_runid = spect_run.id where spect_run.run_tag like '%pilot%';
# Join 3 tables:
select c.comp_id,c.component_name,c.flux_peak,c.has_siblings,p.run_tag from component c inner join SBID s  on s.id = c.sbid_id inner join spect_run p on p.id = s.spect_runid where p.run_tag like '%survey 1' order by c.comp_id;
select distinct s.sbid_num from component c inner join SBID s on s.id = c.sbid_id where c.flux_peak < 45;

# Update with join:
update sbid s set version = 1 from spect_run r where s.spect_runid = r.id and r.run_tag = 'FLASH Survey 1';
update sbid s set spectral_config_tar = r.config_tar from spect_run r where s.spect_runid = r.id;
update sbid s set results = r.results from detect_run r where s.spect_runid = r.id;

# Finding large objects:
select oid, s.sbid_num from pg_largeobject_metadata m inner join sbid s on m.oid = s.detect_tar;
# delete large object:
lo_unlink(oid)

# Delete duplicate records - join table to itself:
delete from component a using component b where a.id < b.id and a.comp_id = b.comp_id;

# Changing primary keys:
alter table sbid drop constraint sbid_pkey cascade;
alter table sbid add column id serial primary key;

# Changing primary key on large table:
alter table component drop constraint component_pkey;
alter table component add column id int;
UPDATE component SET id = t.rownum FROM (SELECT comp_id, row_number() OVER (ORDER BY spectral_date ASC) as rownum FROM component) t WHERE component.comp_id = t.comp_id;
alter table component alter column id set not null;
alter table component add constraint id_unique unique (id);
alter table component alter column id ADD GENERATED BY DEFAULT AS IDENTITY (start with 59034);


# Adding dependent foreign key
alter table component add column sbid_id int;
update component c set sbid_id = id from sbid s where c.sbid = s.sbid_num;
alter table component add constraint fk_sbid_id foreign key(sbid_id) REFERENCES sbid(id) on delete cascade;

create table spectral_plot (
    plot_id varchar(100) PRIMARY KEY,
    comp_id varchar(100) NOT NULL,
    runid int,
    creation_date TIMESTAMP NOT NULL,
    plot_type varchar(20) NOT NULL,
    platform varchar(50),
    plot bytea NOT NULL,
    constraint fk_run
        foreign key(runid) references spect_run(id)
        on delete cascade,
    constraint fk_comp50356,50358,50359,50360,51015,51016,51017,51438,51439,51440,51441,51442,51443
        foreign key(comp_id) references component(comp_id)
        on delete cascade
);

create table detection (
    id int generated always as identity PRIMARY KEY,
    comp_id varchar(100) NOT NULL,
    runid int,
    creation_date TIMESTAMP NOT NULL,
    platform varchar(50),
    constraint fk_comp
        foreign key(comp_id) references component(comp_id)
        on delete cascade,
    constraint fk_run
        foreign key(runid) references detect_run(id)
        on delete cascade
);

#########################################################################################
######## Delelte tables ######################################
drop table detection cascade;
drop table spectral_plot cascade;
drop table component cascade;
drop table sbid cascade;
drop table detect_run cascade;
drop table spect_run cascade;


# To read in binary/text data, user flash needs the following grants.
# Add as superuser (attached to 'flashdb' database) :
GRANT EXECUTE ON FUNCTION pg_read_binary_file(text) TO flash;
GRANT EXECUTE ON FUNCTION pg_read_binary_file(text,bigint,bigint) TO flash;
GRANT EXECUTE ON FUNCTION pg_read_binary_file(text,bigint,bigint,boolean) TO flash;
GRANT EXECUTE ON FUNCTION pg_read_file(text) TO flash;
GRANT EXECUTE ON FUNCTION pg_read_file(text,bigint,bigint) TO flash;
GRANT EXECUTE ON FUNCTION pg_read_file(text,bigint,bigint,boolean) TO flash;
    
######### ADDING DATA ###########################################
######### with SQL:

# install psycopg2
sudo apt install pip
sudo apt-get install --reinstall libpq-dev
sudo pip install psycopg2

