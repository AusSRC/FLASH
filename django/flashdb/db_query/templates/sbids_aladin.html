<!DOCTYPE html>
<html>
<head>
    <title>FLASHDB</title>
    <style>
    .black-border {
        border: 2px solid black;
        padding: 4px;
    }
    .column {
        flex: 1; /* Allows columns to grow and shrink equally */
        /* You can add other styling here, e.g., background-color, padding */
    }
    .legend-list {
        list-style-type: none;
        padding: 0;
    }
    .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
    }
    .legend-color-box {
        width: 20px;
        height: 20px;
        margin-right: 10px;
    }
    </style>
    <!--Include bootstrap things-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.3.0/font/bootstrap-icons.css">    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- our code needs jQuery library -->
    <script type="text/javascript" src="http://code.jquery.com/jquery-1.9.1.min.js" charset="utf-8"></script>
    <!-- Aladin Lite JS code -->
    <script type="text/javascript" src="https://aladin.cds.unistra.fr/AladinLite/api/v3/latest/aladin.js" charset="utf-8"></script>
</head>
<body style="background-color:#ABB2B9;">
  {{ sbids|json_script:"sbids-data" }}  
  <div class="container-fluid blackborder" style="background-color:aquamarine;">
    <H1 style="text-align: center;">FLASH Survey Progress</H1>
    {% load static %}
    <div class="container black-border" style="display:flex; gap:20px; border:none;">
      <img src="{% static 'db_query/SKAO_ausSRC_logo_colour_white_bg.png' %}" alt="AusSRC" style="top:20px; right:30px;" width="200" height="100">          
      <!-- Create a legend for the type of detections -->  
      <div class="column black-border" id="myLegendContainer">
        <ul class="legend-list">
          <li class="legend-item"><span class="legend-color-box" style="background-color: green;"></span>MASKED DETECTION</li>
          <li class="legend-item"><span class="legend-color-box" style="background-color: yellow;"></span>INVERTED DETECTION</li>
          <li class="legend-item"><span class="legend-color-box" style="background-color: blue;"></span>STANDARD DETECTION</li>
          <li class="legend-item"><span class="legend-color-box" style="background-color: grey;"></span>NO DETECTION</li>            
        </ul>      
      </div>      
      <div class='column black-border' id='run_summary'></div>
      <div class='column black-border' id='status_summary'></div>	  
      <img src="{% static 'db_query/flash.jpeg' %}" alt="FLASH" style="top:20px; left:30px;" width="180" height="100">
    </div>   
    <p id='total_sbids' style="text-align: center;">Total number of SBIDs shown = {{num_sbids}}</p> 
    <form action="/db_query/">
      <input type="hidden" id="session_id" name="session_id" value={{ session_id }}/>                
      <input type="submit" value="Return to Main page"/>
      <button type="button" class="btn btn-primary dropdown-toggle" data-bs-toggle="dropdown">
        View By Tag: <span id="selectedTag">All</span>
      </button>
      <ul class="dropdown-menu">
        <li><a class="dropdown-item active" href="#">All</a></li>
        <li><a class="dropdown-item" href="#">Flash Pilot 1</a></li>
        <li><a class="dropdown-item" href="#">Flash Pilot 2</a></li>
        <li><a class="dropdown-item" href="#">Flash Survey 1</a></li>
      </ul>        
      <input type="checkbox" id="hideRejected" unchecked> Hide Rejected Observations
      <input type="checkbox" id="hideUncertain" unchecked> Hide Uncertain Observations
      <input type="checkbox" id="hideNotValidated" unchecked> Hide Not Validated      
    </form>
  </div>
  <div class="container-fluid border">
     <!-- Aladin Lite container at requested dimensions -->
     <div id="aladin-lite-div" style="width:1000px;height:700px;"></div>
  </div>
  <!-- Creation of Aladin Lite instance with initial parameters -->
  <script type="text/javascript"> 
    let aladin;
    let tiles = JSON.parse(document.getElementById('sbids-data').textContent);
    // link sources to overlays so we can hide overlays when sources are hidden
    const sourceToDetectionMap = new Map();
    // create catalogs for status
    var goodCat = A.catalog({name: 'Good Observations', shape: 'circle', color: 'blue', onClick: 'showPopup'});
    var uncertainCat = A.catalog({name: 'Uncertain Observations', shape: 'square', color: 'grey', onClick: 'showPopup'});
    var rejectedCat = A.catalog({name: 'Rejected Observations', shape: 'cross', color: 'red', onClick: 'showPopup'});
    var notValidatedCat = A.catalog({name: 'Not Validated', shape: 'triangle', color: 'white', onClick: 'showPopup'});
    // create layers based on detection runs 
    var detectLayer = A.graphicOverlay({name:'Detections', color: 'green', opacity: 0.5, lineWidth: 1});
     
    A.init.then(() => {
      // set up aladin
      aladin = A.aladin('#aladin-lite-div', {survey: "P/DSS2/color", fov: 1.5, target: "trifid nebula"});

      // add catalogs for status
      aladin.addCatalog(goodCat);
      aladin.addCatalog(uncertainCat);
      aladin.addCatalog(rejectedCat);
      aladin.addCatalog(notValidatedCat);
      // add layers based on detection runs 
      aladin.addOverlay(detectLayer);
      
      tiles.forEach(sbid => {
        var ra = parseFloat(sbid[3]);
        var dec = parseFloat(sbid[4]);

        // Create catalog sources
        var marker = A.source(ra, dec,
                  {SBID: sbid[0], FIELD: sbid[1], STATUS: sbid[5], TAG: sbid[9]});
        switch(sbid[5]) {
            case "GOOD":
                goodCat.addSources([marker]);
                break;
            case "UNCERTAIN":
                uncertainCat.addSources([marker]);
                break;
            case "REJECTED":
                rejectedCat.addSources([marker]);
                break;
            default:
                notValidatedCat.addSources([marker]);
                break;
        }
                  
        // detection shapes
        d_ra_upper = 3.0 / Math.cos((dec + 3.0) * Math.PI / 180.0);
        d_ra_lower = 3.0 / Math.cos((dec - 3.0)* Math.PI / 180.0);
        shape = A.polygon([
                    [ra + d_ra_lower, dec - 3.0],
                    [ra - d_ra_lower, dec - 3.0],
                    [ra - d_ra_upper, dec + 3.0],
                    [ra + d_ra_upper, dec + 3.0]
        ]);
        shape.fill = true;
        shape.opacity = 0.3;
        sourceToDetectionMap.set(marker, shape); // link source to detection shape
        if (sbid[8] === true) {
          shape.fillColor = 'green';
        } else if (sbid[7] === true) {
          shape.fillColor = 'yellow';
        } else if (sbid[6] === true) {
          shape.fillColor = 'blue';
        } else {
          shape.fillColor = 'grey';
        }               
        detectLayer.addFootprints([shape]);
      });
      updateTotalSBIDs();     
    });
  
  hideAndShowBasedOnStatus();

  hideAndShowBasedOnTagSelection();
  
  function hideAndShowBasedOnStatus() {
    const filters = [{
      checkboxId: 'hideRejected',
      status: 'REJECTED',
      catalog: rejectedCat
    }, {
     checkboxId: 'hideUncertain',
     status: 'UNCERTAIN',
     catalog: uncertainCat
    }, {
     checkboxId: 'hideNotValidated',
     status: 'NOT VALIDATED',
     catalog: notValidatedCat
    }];
    filters.forEach(({ checkboxId, status, catalog }) => {
      document.getElementById(checkboxId).addEventListener('change', function () {
        const show = !this.checked;
        // Show/hide the catalog
        catalog[show ? 'show' : 'hide']();
        // Show/hide corresponding detections
        sourceToDetectionMap.forEach((detection, source) => {
          if (source.data['STATUS'] === status) {
            // also check the tag 
            if (show && isTagSelected(source)) {
                source.show();
                detection.show();
            } else {
                source.hide();
                detection.hide();
            }
          }
        });
        updateTotalSBIDs();
      });     
    });
  }
  
  function hideAndShowBasedOnTagSelection() {
    // Manage tag selection  
    const tagLabel = document.getElementById('selectedTag');
    document.querySelectorAll('.dropdown-item').forEach(item => {
      item.addEventListener('click', function (e) {
        e.preventDefault();
        // Update the label in the button
        tagLabel.textContent = this.textContent;
        // Highlight selected
        document.querySelectorAll('.dropdown-item').forEach(i => i.classList.remove('active'));
        this.classList.add('active');
        // tag-based filtering logic here
        const catalogs = [goodCat, uncertainCat, rejectedCat, notValidatedCat];
        catalogs.forEach(cat => {
          cat.sources.forEach(source => {
            const detection = sourceToDetectionMap.get(source);
              if (isTagSelected(source) && cat.isShowing) {
                source.show();
                detection.show();
              } else {
                source.hide();
                detection.hide();
              }
          });
        }); 
        updateTotalSBIDs();
      });
    });
  }
  function isTagSelected(source) {
    if (document.getElementById('selectedTag').textContent === 'All' || 
        (source.data['TAG'] &&
          source.data['TAG'].toUpperCase() === document.getElementById('selectedTag').textContent.toUpperCase()
        )) {
            return true;
    }
    return false;
  }
  function isMaskDetection(source) {
    const detection = sourceToDetectionMap.get(source);
    return detection && detection.fillColor === 'green';
  }
  function isInvertedDetection(source) {
    const detection = sourceToDetectionMap.get(source);
    return detection && detection.fillColor === 'yellow';
  }
  function isStandardDetection(source) {
    const detection = sourceToDetectionMap.get(source);
    return detection && detection.fillColor === 'blue';
  }
  function isNoDetection(source) {
    const detection = sourceToDetectionMap.get(source);
    return detection && detection.fillColor === 'grey';
  }
  function updateTotalSBIDs() {
    let count = 0;
    let countPerStatus = [0,0,0,0]; // good, uncertain, rejected, not validated
    let maskedCount = 0;
    let invertedCount = 0;
    let standardCount = 0;
    let noDetectCount = 0;
    let idx = 0;
    [goodCat, uncertainCat, rejectedCat, notValidatedCat].forEach(cat => {
        if (cat.isShowing) {
            countPerStatus[idx] = cat.sources.filter(source => source.isShowing).length;
            count += countPerStatus[idx];
            idx+=1;
            maskedCount += cat.sources.filter(source => source.isShowing && isMaskDetection(source)).length;
            invertedCount += cat.sources.filter(source => source.isShowing && isInvertedDetection(source)).length;
            standardCount += cat.sources.filter(source => source.isShowing && isStandardDetection(source)).length;
            noDetectCount += cat.sources.filter(source => source.isShowing && isNoDetection(source)).length;
        }
    });    
    document.getElementById('run_summary').innerHTML = "<br>MASKED DETECTION runs  = "+ maskedCount
              +"<br>INVERTED DETECTION  runs = " + invertedCount
              + "<br>STANDARD DETECTION runs = " + standardCount
              + "<br>NO DETECTION = " + noDetectCount + "<br>";
    document.getElementById('status_summary').innerHTML = "<br>GOOD observations  = "+ countPerStatus[0]
              + "<br>UNCERTAIN observations = " + countPerStatus[1]
              + "<br>REJECTED observations = " + countPerStatus[2]
              + "<br>NOT VALIDATED = " + countPerStatus[3] + "<br>";
    document.getElementById('total_sbids').textContent = `Total number of SBIDs shown = ${count}`;
  }
  </script>
</body>